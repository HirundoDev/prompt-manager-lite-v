#!/usr/bin/env python3
"""
The Mighty Task - Playbook Processor
====================================

Parsea playbooks originales y genera templates espec√≠ficos para cada sesi√≥n.

Uso:
    python scripts/playbook-processor.py --date="2024-01-15" --theme="BACKEND-API-SETUP"
    python scripts/playbook-processor.py --playbook="DOC006" --output-dir="/path/to/session/"
    python scripts/playbook-processor.py --scan-all --list-playbooks

Autor: The Mighty Task System
Fecha: 2025-01-22
"""

import os
import sys
import json
import argparse
import re
from datetime import datetime
from pathlib import Path

# Mapeo de temas a playbooks (igual que en generate-daily.py)
THEME_PLAYBOOK_MAPPING = {
    'FRONTEND-ARCHITECTURE': ['DOC004'],
    'FRONTEND-COMPONENTS': ['DOC003', 'DOC004'],
    'FRONTEND-DEPENDENCIES': ['DOC005'],
    'DESIGN-SYSTEM': ['DOC003'],
    'BACKEND-API-SETUP': ['DOC006', 'DOC007', 'DOC008'],
    'BACKEND-ARCHITECTURE': ['DOC006', 'DOC007'],
    'API-DESIGN': ['DOC008'],
    'DATABASE-SCHEMA': ['DOC009'],
    'DATA-MODELING': ['DOC009'],
    'DEPLOYMENT-CONFIG': ['DOC010'],
    'DEVOPS-SETUP': ['DOC010'],
    'TESTING-STRATEGY': ['DOC011'],
    'CLI-DEVELOPMENT': ['DOC019']
}

# Mapeo de c√≥digos DOC a nombres de archivos
PLAYBOOK_FILE_MAPPING = {
    'DOC003': 'DOC003-DesignSystem.md',
    'DOC004': 'DOC004-FrontendArchitecture.md',
    'DOC005': 'DOC005-FrontendDependencies.md',
    'DOC006': 'DOC006-BackendArchitecture.md',
    'DOC007': 'DOC007-BackendDependencies.md',
    'DOC008': 'DOC008-APISpecification.md',
    'DOC009': 'DOC009-DataModel.md',
    'DOC010': 'DOC010-Deployment.md',
    'DOC011': 'DOC011-TestingStrategy.md',
    'DOC019': 'DOC019-CLI-Command-Reference.md'
}

class ColoredOutput:
    """Clase para output con colores en terminal."""
    COLORS = {
        'RED': '\033[91m',
        'GREEN': '\033[92m',
        'YELLOW': '\033[93m',
        'BLUE': '\033[94m',
        'MAGENTA': '\033[95m',
        'CYAN': '\033[96m',
        'WHITE': '\033[97m',
        'BOLD': '\033[1m',
        'UNDERLINE': '\033[4m',
        'END': '\033[0m'
    }
    
    @classmethod
    def print(cls, text, color='WHITE', bold=False, underline=False):
        """Imprime texto con formato."""
        prefix = ""
        if bold:
            prefix += cls.COLORS['BOLD']
        if underline:
            prefix += cls.COLORS['UNDERLINE']
        if color in cls.COLORS:
            prefix += cls.COLORS[color]
        
        print(f"{prefix}{text}{cls.COLORS['END']}")
    
    @classmethod
    def success(cls, text):
        cls.print(f"‚úÖ {text}", 'GREEN', bold=True)
    
    @classmethod
    def error(cls, text):
        cls.print(f"‚ùå {text}", 'RED', bold=True)
    
    @classmethod
    def warning(cls, text):
        cls.print(f"‚ö†Ô∏è  {text}", 'YELLOW', bold=True)
    
    @classmethod
    def info(cls, text):
        cls.print(f"‚ÑπÔ∏è  {text}", 'CYAN')
    
    @classmethod
    def header(cls, text):
        cls.print(f"\n{'=' * 60}", 'BLUE')
        cls.print(f"  {text}", 'BLUE', bold=True, underline=True)
        cls.print(f"{'=' * 60}\n", 'BLUE')

class PlaybookProcessor:
    """Procesador de playbooks que genera templates espec√≠ficos."""
    
    def __init__(self, base_path=None):
        self.base_path = Path(base_path or os.getcwd())
        self.playbooks_dir = self.base_path / 'playbooks' / 'documentation_playbooks'
        self.daily_work_dir = self.base_path / 'daily-work'
        self.tracking_file = self.daily_work_dir / '.tracking.json'
        
        # Verificar estructura del proyecto
        if not (self.base_path / 'PLAN-COMPLETO.md').exists():
            ColoredOutput.error("No est√°s en el directorio ra√≠z de The Mighty Task")
            ColoredOutput.info("Ejecuta este script desde el directorio que contiene PLAN-COMPLETO.md")
            sys.exit(1)
        
        if not self.playbooks_dir.exists():
            ColoredOutput.error(f"Directorio de playbooks no encontrado: {self.playbooks_dir}")
            sys.exit(1)
    
    def load_tracking_data(self):
        """Carga los datos de tracking existentes."""
        if self.tracking_file.exists():
            try:
                with open(self.tracking_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except (json.JSONDecodeError, FileNotFoundError):
                ColoredOutput.warning("Archivo de tracking corrupto o no encontrado")
        
        return {"processed_dates": [], "playbook_usage": {}, "consistency_checks": {}}
    
    def save_tracking_data(self, data):
        """Guarda los datos de tracking."""
        try:
            self.tracking_file.parent.mkdir(parents=True, exist_ok=True)
            with open(self.tracking_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
            return True
        except Exception as e:
            ColoredOutput.error(f"Error guardando tracking: {e}")
            return False
    
    def find_session_directory(self, date_str, theme):
        """Encuentra el directorio de sesi√≥n basado en fecha y tema."""
        session_name = f"{date_str}_{theme}"
        session_dir = self.daily_work_dir / session_name
        
        if not session_dir.exists():
            ColoredOutput.error(f"Sesi√≥n no encontrada: {session_name}")
            ColoredOutput.info("Ejecuta primero: python scripts/generate-daily.py")
            return None
        
        support_docs_dir = session_dir / 'support-docs'
        if not support_docs_dir.exists():
            ColoredOutput.error(f"Directorio support-docs no encontrado en: {session_dir}")
            return None
        
        return session_dir
    
    def get_available_playbooks(self):
        """Obtiene la lista de playbooks disponibles."""
        available = []
        for playbook_code, filename in PLAYBOOK_FILE_MAPPING.items():
            playbook_path = self.playbooks_dir / filename
            if playbook_path.exists():
                available.append((playbook_code, filename, playbook_path))
            else:
                ColoredOutput.warning(f"Playbook no encontrado: {filename}")
        
        return available
    
    def load_playbook(self, playbook_path):
        """Carga y parsea un playbook desde archivo."""
        try:
            with open(playbook_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            return self.parse_playbook_structure(content, playbook_path.name)
        except Exception as e:
            ColoredOutput.error(f"Error cargando playbook {playbook_path}: {e}")
            return None
    
    def parse_playbook_structure(self, content, filename):
        """Parsea la estructura de un playbook y extrae informaci√≥n relevante."""
        
        # Extraer metadatos del header
        metadata = self.extract_metadata(content)
        
        # Extraer estructura de headers
        headers = self.extract_header_structure(content)
        
        # Extraer secciones principales
        sections = self.extract_sections(content, headers)
        
        return {
            'filename': filename,
            'metadata': metadata,
            'headers': headers,
            'sections': sections,
            'content_length': len(content),
            'parsed_at': datetime.now().isoformat()
        }
    
    def extract_metadata(self, content):
        """Extrae metadatos del header del playbook."""
        metadata = {
            'title': 'Sin t√≠tulo',
            'description': 'Sin descripci√≥n',
            'version': '1.0',
            'author': 'The Mighty Task',
            'creation_date': None,
            'last_update': None
        }
        
        # Buscar t√≠tulo (primera l√≠nea con #)
        title_match = re.search(r'^#\s+(.+)$', content, re.MULTILINE)
        if title_match:
            metadata['title'] = title_match.group(1).strip()
        
        # Buscar descripci√≥n en las primeras l√≠neas
        lines = content.split('\n')
        for i, line in enumerate(lines[:20]):  # Solo primeras 20 l√≠neas
            if line.startswith('**Descripci√≥n:**') or line.startswith('**Description:**'):
                if i + 1 < len(lines):
                    metadata['description'] = lines[i + 1].strip()
                break
            elif 'descripci√≥n' in line.lower() and not line.startswith('#'):
                metadata['description'] = line.strip()
                break
        
        # Buscar versi√≥n
        version_match = re.search(r'\*\*Versi√≥n:\*\*\s*(.+)', content, re.IGNORECASE)
        if version_match:
            metadata['version'] = version_match.group(1).strip()
        
        return metadata
    
    def extract_header_structure(self, content):
        """Extrae la estructura jer√°rquica de headers."""
        headers = []
        
        # Patr√≥n para headers de markdown (# ## ### etc.)
        header_pattern = r'^(#{1,6})\s+(.+)$'
        
        for match in re.finditer(header_pattern, content, re.MULTILINE):
            level = len(match.group(1))  # N√∫mero de #
            title = match.group(2).strip()
            position = match.start()
            
            headers.append({
                'level': level,
                'title': title,
                'position': position,
                'anchor': self.create_anchor(title)
            })
        
        return headers
    
    def create_anchor(self, title):
        """Crea un anchor para navegaci√≥n interna."""
        # Convertir a formato anchor de markdown
        anchor = title.lower()
        anchor = re.sub(r'[^\w\s-]', '', anchor)  # Quitar caracteres especiales
        anchor = re.sub(r'\s+', '-', anchor)  # Espacios a guiones
        return anchor
    
    def extract_sections(self, content, headers):
        """Extrae el contenido de cada secci√≥n basado en headers."""
        sections = []
        
        for i, header in enumerate(headers):
            start_pos = header['position']
            
            # Encontrar el final de esta secci√≥n (siguiente header del mismo nivel o superior)
            end_pos = len(content)
            for next_header in headers[i + 1:]:
                if next_header['level'] <= header['level']:
                    end_pos = next_header['position']
                    break
            
            # Extraer contenido de la secci√≥n
            section_content = content[start_pos:end_pos].strip()
            
            # Analizar tipo de contenido
            content_analysis = self.analyze_section_content(section_content)
            
            sections.append({
                'header': header,
                'content': section_content,
                'length': len(section_content),
                'analysis': content_analysis
            })
        
        return sections
    
    def analyze_section_content(self, section_content):
        """Analiza el tipo de contenido en una secci√≥n."""
        analysis = {
            'has_code_blocks': bool(re.search(r'```', section_content)),
            'has_tables': bool(re.search(r'\|.*\|', section_content)),
            'has_lists': bool(re.search(r'^[\*\-\+]\s', section_content, re.MULTILINE)),
            'has_checkboxes': bool(re.search(r'- \[ \]', section_content)),
            'has_links': bool(re.search(r'\[.+\]\(.+\)', section_content)),
            'has_images': bool(re.search(r'!\[.+\]\(.+\)', section_content)),
            'paragraph_count': len([p for p in section_content.split('\n\n') if p.strip()]),
            'content_type': 'mixed'
        }
        
        # Determinar tipo predominante de contenido
        if analysis['has_code_blocks']:
            analysis['content_type'] = 'code-heavy'
        elif analysis['has_tables']:
            analysis['content_type'] = 'table-heavy'
        elif analysis['has_lists'] or analysis['has_checkboxes']:
            analysis['content_type'] = 'list-heavy'
        elif analysis['paragraph_count'] > 3:
            analysis['content_type'] = 'text-heavy'
        
        return analysis
    
    def generate_template_from_playbook(self, playbook_data, theme, date_str):
        """Genera un template basado en la estructura del playbook."""
        
        template_content = []
        
        # Header del template
        template_content.append(f"# {playbook_data['metadata']['title']}")
        template_content.append("")
        template_content.append(f"**Generado autom√°ticamente para:** {theme} - {date_str}")
        template_content.append(f"**Basado en:** {playbook_data['filename']}")
        template_content.append(f"**Fecha de generaci√≥n:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        template_content.append("")
        template_content.append("---")
        template_content.append("")
        
        # Nota importante
        template_content.append("## üìã Instrucciones de Uso")
        template_content.append("")
        template_content.append("Este archivo es un **TEMPLATE** generado autom√°ticamente.")
        template_content.append("- ‚úÖ **S√ç completa** las secciones marcadas con `[TODO]`")
        template_content.append("- ‚úÖ **S√ç agrega** informaci√≥n espec√≠fica de tu trabajo")
        template_content.append("- ‚ùå **NO modifiques** el playbook original")
        template_content.append("- üìö **Usa el playbook original** como gu√≠a y referencia")
        template_content.append("")
        template_content.append(f"üìñ **Playbook original:** `playbooks/documentation_playbooks/{playbook_data['filename']}`")
        template_content.append("")
        template_content.append("---")
        template_content.append("")
        
        # Generar estructura basada en headers
        for section in playbook_data['sections']:
            header = section['header']
            analysis = section['analysis']
            
            # Solo procesar headers de nivel 1-3 para evitar demasiado detalle
            if header['level'] <= 3:
                template_content.append('#' * header['level'] + ' ' + header['title'])
                template_content.append("")
                
                # Generar contenido espec√≠fico basado en el an√°lisis
                todo_content = self.generate_todo_content(header['title'], analysis, theme)
                template_content.extend(todo_content)
                template_content.append("")
        
        # Footer del template
        template_content.append("---")
        template_content.append("")
        template_content.append("## ‚úÖ Checklist de Completitud")
        template_content.append("")
        template_content.append("- [ ] Todas las secciones [TODO] completadas")
        template_content.append("- [ ] Informaci√≥n espec√≠fica del proyecto agregada")
        template_content.append("- [ ] Referencias y enlaces actualizados")
        template_content.append("- [ ] Ejemplos de c√≥digo incluidos (si aplica)")
        template_content.append("- [ ] Documentaci√≥n revisada y validada")
        template_content.append("")
        template_content.append("---")
        template_content.append(f"*Template generado autom√°ticamente por The Mighty Task System*  ")
        template_content.append(f"*Para m√°s informaci√≥n, consultar: `playbooks/documentation_playbooks/{playbook_data['filename']}`*")
        
        return '\n'.join(template_content)
    
    def determine_template_type(self, filename):
        """Determina el tipo de template seg√∫n el DOC"""
        doc_mapping = {
            'DOC003-DesignSystem.md': 'design_system',
            'DOC004-FrontendArchitecture.md': 'frontend_architecture',
            'DOC005-FrontendDependencies.md': 'frontend_dependencies',
            'DOC006-BackendArchitecture.md': 'backend_architecture',
            'DOC007-BackendDependencies.md': 'backend_dependencies',
            'DOC008-APISpecification.md': 'api_specification',
            'DOC009-DataModel.md': 'data_model',
            'DOC010-Deployment.md': 'deployment',
            'DOC011-TestingStrategy.md': 'testing_strategy',
            'DOC019-CLI-Command-Reference.md': 'cli_reference'
        }
        return doc_mapping.get(filename, 'generic')
    
    def create_universal_template(self, template_type, theme, date_str, filename):
        """Crea un marco de referencia universal seg√∫n el tipo"""
        templates = {
            'design_system': self.create_design_system_template,
            'frontend_architecture': self.create_frontend_architecture_template,
            'frontend_dependencies': self.create_frontend_dependencies_template,
            'backend_architecture': self.create_backend_architecture_template,
            'backend_dependencies': self.create_backend_dependencies_template,
            'api_specification': self.create_api_specification_template,
            'data_model': self.create_data_model_template,
            'deployment': self.create_deployment_template,
            'testing_strategy': self.create_testing_strategy_template,
            'cli_reference': self.create_cli_reference_template
        }
        
        template_func = templates.get(template_type, self.create_generic_template)
        return template_func(theme, date_str, filename)

    def generate_todo_content(self, section_title, analysis, theme):
        """Genera contenido TODO espec√≠fico basado en la secci√≥n y tema."""
        todo_content = []
        
        # Personalizar seg√∫n el tipo de secci√≥n
        section_lower = section_title.lower()
        
        if any(keyword in section_lower for keyword in ['arquitectura', 'architecture', 'estructura', 'structure']):
            todo_content = [
                f"[TODO] Definir la arquitectura espec√≠fica para {theme}:",
                "",
                "### Componentes Principales",
                "- [TODO] Componente 1: Descripci√≥n y responsabilidades",
                "- [TODO] Componente 2: Descripci√≥n y responsabilidades", 
                "- [TODO] Componente 3: Descripci√≥n y responsabilidades",
                "",
                "### Patrones de Dise√±o",
                "- [TODO] Patr√≥n principal utilizado",
                "- [TODO] Justificaci√≥n de la elecci√≥n",
                "",
                "### Dependencias",
                "- [TODO] Listar dependencias externas",
                "- [TODO] Especificar versiones requeridas",
            ]
        
        elif any(keyword in section_lower for keyword in ['instalaci√≥n', 'installation', 'setup', 'configuraci√≥n']):
            todo_content = [
                f"[TODO] Configurar entorno para {theme}:",
                "",
                "### Prerrequisitos",
                "```bash",
                "# [TODO] Comandos de instalaci√≥n de prerrequisitos",
                "```",
                "",
                "### Pasos de Instalaci√≥n",
                "1. [TODO] Paso 1 con comando espec√≠fico",
                "2. [TODO] Paso 2 con comando espec√≠fico",
                "3. [TODO] Paso 3 con comando espec√≠fico",
                "",
                "### Verificaci√≥n",
                "```bash",
                "# [TODO] Comandos para verificar instalaci√≥n",
                "```",
            ]
        
        elif any(keyword in section_lower for keyword in ['ejemplos', 'examples', 'uso', 'usage']):
            todo_content = [
                f"[TODO] Ejemplos espec√≠ficos para {theme}:",
                "",
                "### Ejemplo B√°sico",
                "```bash",
                "# [TODO] Ejemplo de uso b√°sico",
                "```",
                "",
                "### Ejemplo Avanzado", 
                "```bash",
                "# [TODO] Ejemplo de uso avanzado",
                "```",
                "",
                "### Casos de Uso Comunes",
                "- [TODO] Caso de uso 1",
                "- [TODO] Caso de uso 2",
                "- [TODO] Caso de uso 3",
            ]
        
        elif any(keyword in section_lower for keyword in ['api', 'endpoints', 'rutas', 'routes']):
            todo_content = [
                f"[TODO] Definir APIs para {theme}:",
                "",
                "### Endpoints Principales",
                "",
                "#### GET /[TODO-endpoint]",
                "- **Descripci√≥n:** [TODO] Descripci√≥n del endpoint",
                "- **Par√°metros:** [TODO] Listar par√°metros",
                "- **Respuesta:** [TODO] Estructura de respuesta",
                "",
                "#### POST /[TODO-endpoint]",
                "- **Descripci√≥n:** [TODO] Descripci√≥n del endpoint",
                "- **Body:** [TODO] Estructura del body",
                "- **Respuesta:** [TODO] Estructura de respuesta",
                "",
                "### Autenticaci√≥n",
                "- [TODO] M√©todo de autenticaci√≥n",
                "- [TODO] Headers requeridos",
            ]
        
        elif any(keyword in section_lower for keyword in ['testing', 'pruebas', 'tests']):
            todo_content = [
                f"[TODO] Estrategia de testing para {theme}:",
                "",
                "### Tests Unitarios",
                "- [TODO] Framework de testing elegido",
                "- [TODO] Cobertura objetivo (%)",
                "",
                "### Tests de Integraci√≥n",
                "- [TODO] Herramientas para tests de integraci√≥n",
                "- [TODO] Scenarios principales a testear",
                "",
                "### Tests End-to-End",
                "- [TODO] Herramientas E2E",
                "- [TODO] Flows cr√≠ticos a testear",
            ]
        
        else:
            # Contenido gen√©rico basado en el an√°lisis
            todo_content = [
                f"[TODO] Completar informaci√≥n para: {section_title}",
                "",
                "### Informaci√≥n Principal",
                "- [TODO] Punto clave 1",
                "- [TODO] Punto clave 2", 
                "- [TODO] Punto clave 3",
                ""
            ]
            
            if analysis.get('has_code_blocks', False):
                todo_content.extend([
                    "### Ejemplos de C√≥digo",
                    "```bash",
                    "# [TODO] Agregar ejemplos de c√≥digo espec√≠ficos",
                    "```",
                    ""
                ])
            
            if analysis.get('has_tables', False):
                todo_content.extend([
                    "### Informaci√≥n Tabular",
                    "",
                    "| Campo | Valor | Descripci√≥n |",
                    "|-------|-------|-------------|",
                    "| [TODO] | [TODO] | [TODO] |",
                    ""
                ])
        
        return todo_content
    
    # =====================================================================
    # TEMPLATES UNIVERSALES - MARCOS DE REFERENCIA POR TIPO
    # =====================================================================
    
    def create_design_system_template(self, theme, date_str, filename):
        """Marco de referencia para sistemas de dise√±o"""
        return f'''# Sistema de Dise√±o - Marco de Referencia

**Sesi√≥n:** {theme}  
**Fecha:** {date_str}  
**Marco Universal:** Sistema de Dise√±o  
**Referencia:** [playbooks/documentation_playbooks/{filename}](../../../playbooks/documentation_playbooks/{filename})

---

## üéØ Prop√≥sito del Marco

Este documento sirve como **marco de referencia universal** para sistemas de dise√±o, adaptable a cualquier tecnolog√≠a o framework.

### Decisiones Clave a Capturar
- **Filosof√≠a de dise√±o** adoptada para el proyecto
- **Tokens de dise√±o** definidos y su justificaci√≥n
- **Componentes base** y su jerarqu√≠a
- **Patrones de interacci√≥n** establecidos
- **Herramientas** elegidas y por qu√©

---

## üèóÔ∏è Fundamentos del Sistema

### Filosof√≠a de Dise√±o
**Decisi√≥n:** [Documentar la filosof√≠a de dise√±o elegida]  
**Opciones consideradas:**
- Material Design, Human Interface Guidelines, Atomic Design, Custom
- Razones para la elecci√≥n
- Principios rectores del proyecto

### Tokens de Dise√±o
**Decisi√≥n:** [Definir tokens fundamentales]  

#### Colores
```css
/* Ejemplo - adaptar a tu stack */
--primary: [DEFINIR];
--secondary: [DEFINIR];
--accent: [DEFINIR];
```

#### Tipograf√≠a
- **Fuente principal:** [DECIDIR]
- **Escala tipogr√°fica:** [DEFINIR]
- **Pesos utilizados:** [ESPECIFICAR]

#### Espaciado
```css
/* Sistema de espaciado */
--space-xs: [DEFINIR];
--space-sm: [DEFINIR];
--space-md: [DEFINIR];
```

---

## üß© Arquitectura de Componentes

### Componentes At√≥micos
**Decisi√≥n:** [Listar componentes base identificados]
- Botones: [Variantes y estados]
- Inputs: [Tipos y validaciones]
- Typography: [Elementos y jerarqu√≠as]

### Componentes Moleculares
**Decisi√≥n:** [Componentes compuestos clave]
- Forms: [Patrones de formulario]
- Cards: [Tipos de tarjeta]
- Navigation: [Patrones de navegaci√≥n]

### Plantillas y P√°ginas
**Decisi√≥n:** [Layouts principales]
- Layout principal: [Estructura]
- P√°ginas tipo: [Patrones identificados]

---

## üîß Implementaci√≥n T√©cnica

### Stack Tecnol√≥gico
**Decisi√≥n:** [Tecnolog√≠as elegidas para el design system]

#### Herramientas de Dise√±o
- **Design tool:** [Figma, Sketch, Adobe XD, etc.]
- **Prototipado:** [Herramienta elegida]
- **Documentaci√≥n:** [Storybook, Docusaurus, custom]

#### Stack de Desarrollo
- **Framework:** [React, Vue, Angular, Web Components, etc.]
- **Styling:** [CSS-in-JS, Sass, PostCSS, Tailwind, etc.]
- **Bundler:** [Webpack, Vite, Parcel, etc.]

### Arquitectura del C√≥digo
```
[DEFINIR estructura de carpetas y organizaci√≥n]
```

---

## üì± Responsive & Accessibility

### Estrategia Responsive
**Decisi√≥n:** [Enfoque responsive elegido]
- **Breakpoints:** [Definir breakpoints]
- **Mobile-first:** [S√≠/No y justificaci√≥n]
- **Componentes adaptativos:** [Estrategia]

### Accesibilidad
**Decisi√≥n:** [Est√°ndar de accesibilidad adoptado]
- **WCAG Level:** [AA, AAA]
- **Testing tools:** [Herramientas de testing]
- **Checklist:** [Criterios espec√≠ficos]

---

## üöÄ Implementaci√≥n y Mantenimiento

### Flujo de Desarrollo
**Decisi√≥n:** [Proceso de contribuci√≥n al design system]
1. [Paso 1 del proceso]
2. [Paso 2 del proceso]
3. [Paso 3 del proceso]

### Versionado
**Decisi√≥n:** [Estrategia de versionado]
- **Semantic versioning:** [C√≥mo se aplica]
- **Breaking changes:** [C√≥mo se manejan]
- **Migration guides:** [Proceso]

### Testing
**Decisi√≥n:** [Estrategia de testing para componentes]
- **Unit tests:** [Framework y scope]
- **Visual regression:** [Herramientas]
- **Cross-browser:** [Estrategia]

---

## üìä M√©tricas y Adopci√≥n

### KPIs del Sistema
**Decisi√≥n:** [M√©tricas para medir √©xito]
- Adopci√≥n por equipos: [C√≥mo medir]
- Consistencia: [M√©tricas de consistencia]
- Performance: [Benchmarks]

### Gobernanza
**Decisi√≥n:** [Modelo de gobierno del design system]
- **Design System Team:** [Estructura]
- **Contribuci√≥n:** [Proceso de contribuci√≥n]
- **Evoluci√≥n:** [Proceso de evoluci√≥n]

---

## üîÑ Evoluci√≥n y Roadmap

### Fases de Implementaci√≥n
1. **Fase 1:** [Componentes base y tokens]
2. **Fase 2:** [Componentes compuestos]
3. **Fase 3:** [Templates y patrones]
4. **Fase 4:** [Tooling y automatizaci√≥n]

### Pr√≥ximos Pasos
- [ ] [Tarea inmediata 1]
- [ ] [Tarea inmediata 2]
- [ ] [Tarea inmediata 3]

---

*Marco generado por The Mighty Task System*  
*Consultar playbook original: `playbooks/documentation_playbooks/{filename}`*
'''
    
    def create_backend_architecture_template(self, theme, date_str, filename):
        """Marco de referencia para arquitectura backend"""
        return f'''# Arquitectura Backend - Marco de Referencia

**Sesi√≥n:** {theme}  
**Fecha:** {date_str}  
**Marco Universal:** Arquitectura Backend  
**Referencia:** [playbooks/documentation_playbooks/{filename}](../../../playbooks/documentation_playbooks/{filename})

---

## üéØ Prop√≥sito del Marco

Este documento sirve como **marco de referencia universal** para arquitecturas backend, adaptable a cualquier stack tecnol√≥gico.

### Decisiones Clave a Capturar
- **Patr√≥n arquitect√≥nico** elegido y justificaci√≥n
- **Stack tecnol√≥gico** y razones de elecci√≥n
- **Estrategia de datos** y persistencia
- **Escalabilidad** y performance
- **Seguridad** y autenticaci√≥n

---

## üèóÔ∏è Patr√≥n Arquitect√≥nico

### Arquitectura Elegida
**Decisi√≥n:** [Patr√≥n arquitect√≥nico principal]

**Opciones consideradas:**
- Monol√≠tico / Microservicios / Serverless
- Layered / Hexagonal / Clean Architecture
- Event-Driven / CQRS / Domain-Driven Design

**Justificaci√≥n:** [Por qu√© se eligi√≥ este patr√≥n]

### Estructura de Alto Nivel
```
[DEFINIR estructura general de la aplicaci√≥n]
```

---

## üíª Stack Tecnol√≥gico

### Runtime y Lenguaje
**Decisi√≥n:** [Lenguaje y runtime elegidos]
- **Lenguaje:** [Node.js, Python, Java, Go, Rust, etc.]
- **Version:** [Versi√≥n espec√≠fica]
- **Justificaci√≥n:** [Razones para la elecci√≥n]

### Framework Principal
**Decisi√≥n:** [Framework web elegido]
- **Framework:** [Express, FastAPI, Spring Boot, Gin, Actix, etc.]
- **Alternativas consideradas:** [Otros frameworks evaluados]
- **Raz√≥n de elecci√≥n:** [Criterios de decisi√≥n]

### Base de Datos
**Decisi√≥n:** [Estrategia de persistencia]

#### Base de Datos Principal
- **Tipo:** [SQL, NoSQL, Graph, etc.]
- **Motor:** [PostgreSQL, MongoDB, Redis, Neo4j, etc.]
- **Justificaci√≥n:** [Por qu√© esta elecci√≥n]

#### Cach√© y Performance
- **Cach√©:** [Redis, Memcached, In-memory, etc.]
- **Estrategia:** [Patr√≥n de cache elegido]

---

## üîå APIs y Comunicaci√≥n

### Estilo de API
**Decisi√≥n:** [Estilo de API adoptado]
- **REST** / **GraphQL** / **gRPC** / **WebSockets**
- **Justificaci√≥n:** [Razones para la elecci√≥n]

### Formato de Datos
**Decisi√≥n:** [Formato de intercambio]
- **JSON** / **XML** / **Protocol Buffers** / **MessagePack**
- **Est√°ndares:** [JSON:API, OpenAPI, etc.]

### Documentaci√≥n de API
**Decisi√≥n:** [Herramienta de documentaci√≥n]
- **Swagger/OpenAPI** / **Postman** / **Insomnia** / **Custom**
- **Ubicaci√≥n:** [D√≥nde se encuentra la documentaci√≥n]

---

## üîê Seguridad y Autenticaci√≥n

### Estrategia de Autenticaci√≥n
**Decisi√≥n:** [M√©todo de autenticaci√≥n]
- **JWT** / **OAuth 2.0** / **Session-based** / **API Keys**
- **Provider:** [Auth0, Firebase, Custom, etc.]

### Autorizaci√≥n
**Decisi√≥n:** [Modelo de autorizaci√≥n]
- **RBAC** / **ABAC** / **Custom permissions**
- **Implementation:** [C√≥mo se implementa]

### Seguridad de Datos
**Decisi√≥n:** [Medidas de seguridad implementadas]
- **Encriptaci√≥n:** [En tr√°nsito y en reposo]
- **Validaci√≥n:** [Esquemas y sanitizaci√≥n]
- **Rate limiting:** [Estrategia anti-abuse]

---

## üìä Datos y Persistencia

### Modelo de Datos
**Decisi√≥n:** [Estrategia de modelado]
- **ORM/ODM:** [Prisma, SQLAlchemy, Mongoose, etc.]
- **Migrations:** [Estrategia de migraciones]
- **Seeding:** [Datos iniciales]

### Backup y Recovery
**Decisi√≥n:** [Estrategia de backup]
- **Frecuencia:** [Cada cu√°nto se hace backup]
- **Retenci√≥n:** [Cu√°nto tiempo se conservan]
- **Recovery:** [Proceso de recuperaci√≥n]

---

## ‚ö° Performance y Escalabilidad

### Estrategia de Escalabilidad
**Decisi√≥n:** [C√≥mo escalar la aplicaci√≥n]
- **Horizontal** / **Vertical** / **H√≠brido**
- **Load Balancing:** [Estrategia de balanceeo]
- **Auto-scaling:** [Si aplica y c√≥mo]

### Optimizaciones
**Decisi√≥n:** [Optimizaciones implementadas]
- **Database indexing:** [√çndices definidos]
- **Query optimization:** [Estrategias]
- **Caching layers:** [Niveles de cach√©]

### Monitoring
**Decisi√≥n:** [Herramientas de monitoreo]
- **APM:** [New Relic, DataDog, Elastic APM, etc.]
- **Logs:** [Structured logging, centralized]
- **Metrics:** [Business y technical metrics]

---

## üê≥ Deployment y DevOps

### Containerizaci√≥n
**Decisi√≥n:** [Estrategia de contenedores]
- **Docker:** [S√≠/No y configuraci√≥n]
- **Orchestration:** [Kubernetes, Docker Compose, etc.]

### CI/CD
**Decisi√≥n:** [Pipeline de deployment]
- **CI Tool:** [GitHub Actions, GitLab CI, Jenkins, etc.]
- **Deployment strategy:** [Blue-green, Rolling, Canary]

### Infrastructure
**Decisi√≥n:** [Infraestructura elegida]
- **Cloud Provider:** [AWS, GCP, Azure, Digital Ocean, etc.]
- **IaC:** [Terraform, CloudFormation, Pulumi]

---

## üß™ Testing

### Estrategia de Testing
**Decisi√≥n:** [Niveles de testing implementados]

#### Unit Tests
- **Framework:** [Jest, PyTest, JUnit, etc.]
- **Coverage target:** [Porcentaje objetivo]
- **Mocking strategy:** [C√≥mo se mockea]

#### Integration Tests
- **Database:** [C√≥mo se testea persistencia]
- **External APIs:** [Estrategia para APIs externas]
- **End-to-end:** [Si aplica]

### Test Environment
**Decisi√≥n:** [Ambiente de testing]
- **Database:** [Testing database strategy]
- **External services:** [Mocks vs real services]

---

## üîÑ Pr√≥ximos Pasos y Roadmap

### Implementaci√≥n Inmediata
- [ ] [Tarea 1: Setup inicial]
- [ ] [Tarea 2: Configuraci√≥n base]
- [ ] [Tarea 3: Primer endpoint]

### Fase de Desarrollo
- [ ] [Milestone 1]
- [ ] [Milestone 2]
- [ ] [Milestone 3]

### Optimizaci√≥n y Scaling
- [ ] [Performance tuning]
- [ ] [Security audit]
- [ ] [Monitoring setup]

---

*Marco generado por The Mighty Task System*  
*Consultar playbook original: `playbooks/documentation_playbooks/{filename}`*
'''
    
    def create_generic_template(self, theme, date_str, filename):
        """Template gen√©rico para casos no espec√≠ficos"""
        return f'''# Marco de Referencia - {filename.split('.')[0]}

**Sesi√≥n:** {theme}  
**Fecha:** {date_str}  
**Marco Universal:** {filename.split('.')[0]}  
**Referencia:** [playbooks/documentation_playbooks/{filename}](../../../playbooks/documentation_playbooks/{filename})

---

## üéØ Prop√≥sito del Marco

Este documento sirve como **marco de referencia universal**, adaptable a diferentes tecnolog√≠as y contextos.

### Decisiones Clave a Documentar
- [Identificar decisiones principales para esta √°rea]
- [Listar opciones t√©cnicas relevantes]
- [Capturar justificaciones y trade-offs]
- [Documentar patrones y est√°ndares]

---

## üîß Decisiones T√©cnicas

### Decisi√≥n Principal 1
**Decisi√≥n:** [Describir la decisi√≥n tomada]
**Opciones consideradas:** [Listar alternativas]
**Justificaci√≥n:** [Raz√≥n de la elecci√≥n]

### Decisi√≥n Principal 2
**Decisi√≥n:** [Describir la decisi√≥n tomada]
**Opciones consideradas:** [Listar alternativas]
**Justificaci√≥n:** [Raz√≥n de la elecci√≥n]

### Decisi√≥n Principal 3
**Decisi√≥n:** [Describir la decisi√≥n tomada]
**Opciones consideradas:** [Listar alternativas]
**Justificaci√≥n:** [Raz√≥n de la elecci√≥n]

---

## üèóÔ∏è Implementaci√≥n

### Configuraci√≥n Base
```bash
# Comandos de setup y configuraci√≥n
[COMPLETAR con comandos espec√≠ficos]
```

### Estructura del Proyecto
```
[DEFINIR estructura de carpetas y organizaci√≥n]
```

### Herramientas y Dependencies
- **Principal:** [Herramienta o framework principal]
- **Supporting:** [Herramientas de soporte]
- **Development:** [Herramientas de desarrollo]

---

## üìã Checklist de Implementaci√≥n

### Setup Inicial
- [ ] [Tarea de setup 1]
- [ ] [Tarea de setup 2]
- [ ] [Tarea de setup 3]

### Desarrollo
- [ ] [Tarea de desarrollo 1]
- [ ] [Tarea de desarrollo 2]
- [ ] [Tarea de desarrollo 3]

### Testing y Validaci√≥n
- [ ] [Tarea de testing 1]
- [ ] [Tarea de testing 2]
- [ ] [Tarea de testing 3]

---

## üîÑ Pr√≥ximos Pasos

1. [Paso inmediato 1]
2. [Paso inmediato 2]
3. [Paso inmediato 3]

### Consideraciones Futuras
- [Consideraci√≥n 1]
- [Consideraci√≥n 2]
- [Consideraci√≥n 3]

---

*Marco generado por The Mighty Task System*  
*Consultar playbook original: `playbooks/documentation_playbooks/{filename}`*
'''
    
    def process_theme_playbooks(self, theme, date_str):
        """Procesa todos los playbooks relevantes para un tema."""
        
        ColoredOutput.header(f"Procesando Playbooks para: {theme} - {date_str}")
        
        # Encontrar directorio de sesi√≥n
        session_dir = self.find_session_directory(date_str, theme)
        if not session_dir:
            return False
        
        support_docs_dir = session_dir / 'support-docs'
        
        # Obtener playbooks para este tema
        playbooks_to_process = THEME_PLAYBOOK_MAPPING.get(theme, [])
        if not playbooks_to_process:
            ColoredOutput.warning(f"No hay playbooks mapeados para el tema: {theme}")
            return False
        
        ColoredOutput.info(f"Playbooks a procesar: {', '.join(playbooks_to_process)}")
        
        processed_files = []
        failed_files = []
        
        for playbook_code in playbooks_to_process:
            if playbook_code not in PLAYBOOK_FILE_MAPPING:
                ColoredOutput.warning(f"Playbook {playbook_code} no est√° en el mapeo")
                failed_files.append(playbook_code)
                continue
            
            playbook_filename = PLAYBOOK_FILE_MAPPING[playbook_code]
            playbook_path = self.playbooks_dir / playbook_filename
            
            if not playbook_path.exists():
                ColoredOutput.error(f"Playbook no encontrado: {playbook_path}")
                failed_files.append(playbook_code)
                continue
            
            # Cargar y parsear playbook
            ColoredOutput.info(f"Procesando {playbook_code}: {playbook_filename}")
            playbook_data = self.load_playbook(playbook_path)
            
            if not playbook_data:
                failed_files.append(playbook_code)
                continue
            
            # Generar template
            template_content = self.generate_template_from_playbook(playbook_data, theme, date_str)
            
            # Guardar template
            template_filename = playbook_filename  # Mantener mismo nombre
            template_path = support_docs_dir / template_filename
            
            try:
                with open(template_path, 'w', encoding='utf-8') as f:
                    f.write(template_content)
                
                processed_files.append(str(template_path))
                ColoredOutput.success(f"Template creado: {template_filename}")
                
            except Exception as e:
                ColoredOutput.error(f"Error guardando template {template_filename}: {e}")
                failed_files.append(playbook_code)
        
        # Actualizar tracking
        self.update_processing_tracking(theme, date_str, processed_files, failed_files)
        
        # Mostrar resumen
        self.show_processing_summary(processed_files, failed_files, theme, date_str)
        
        return len(failed_files) == 0
    
    def update_processing_tracking(self, theme, date_str, processed_files, failed_files):
        """Actualiza el tracking con informaci√≥n de procesamiento."""
        tracking_data = self.load_tracking_data()
        
        # Buscar sesi√≥n existente
        session_entry = None
        for session in tracking_data.get('processed_dates', []):
            if session['date'] == date_str and session['theme'] == theme:
                session_entry = session
                break
        
        if session_entry:
            # Actualizar sesi√≥n existente
            session_entry['templates_generated'] = processed_files
            session_entry['templates_failed'] = failed_files
            session_entry['template_generation_date'] = datetime.now().isoformat()
            session_entry['status'] = 'templates_generated'
            session_entry['last_updated'] = datetime.now().isoformat()
            
            self.save_tracking_data(tracking_data)
            ColoredOutput.success("Tracking actualizado correctamente")
        else:
            ColoredOutput.warning("No se encontr√≥ la sesi√≥n en el tracking para actualizar")
    
    def show_processing_summary(self, processed_files, failed_files, theme, date_str):
        """Muestra resumen del procesamiento."""
        
        ColoredOutput.header("Resumen de Procesamiento")
        
        print(f"üìÖ **Fecha:** {date_str}")
        print(f"üéØ **Tema:** {theme}")
        print(f"‚úÖ **Templates generados:** {len(processed_files)}")
        print(f"‚ùå **Errores:** {len(failed_files)}")
        
        if processed_files:
            ColoredOutput.info("\nüìÑ Archivos generados:")
            for file_path in processed_files:
                print(f"  ‚Ä¢ {Path(file_path).name}")
        
        if failed_files:
            ColoredOutput.warning(f"\n‚ö†Ô∏è  Playbooks con errores: {', '.join(failed_files)}")
        
        ColoredOutput.info(f"\nüìÅ Ubicaci√≥n: daily-work/{date_str}_{theme}/support-docs/")
        
        if processed_files:
            ColoredOutput.info("\nPr√≥ximos pasos:")
            print("1. Revisar los templates generados")
            print("2. Completar las secciones marcadas con [TODO]")
            print("3. Usar los playbooks originales como referencia")
            print("4. Validar la informaci√≥n agregada")
    
    def list_available_playbooks(self):
        """Lista todos los playbooks disponibles."""
        
        ColoredOutput.header("Playbooks Disponibles")
        
        available_playbooks = self.get_available_playbooks()
        
        print("üìö **Playbooks en el sistema:**\n")
        
        for playbook_code, filename, path in available_playbooks:
            # Cargar metadatos b√°sicos
            try:
                with open(path, 'r', encoding='utf-8') as f:
                    content = f.read()
                metadata = self.extract_metadata(content)
                
                print(f"üéØ **{playbook_code}** - {filename}")
                print(f"   üìù {metadata['title']}")
                print(f"   üìÑ {metadata['description']}")
                print(f"   üìÇ {path.relative_to(self.base_path)}")
                print()
                
            except Exception as e:
                print(f"üéØ **{playbook_code}** - {filename}")
                print(f"   ‚ùå Error leyendo archivo: {e}")
                print()
        
        print(f"**Total playbooks disponibles:** {len(available_playbooks)}")
        
        # Mostrar mapeo de temas
        ColoredOutput.header("Mapeo de Temas a Playbooks")
        
        for theme, playbooks in THEME_PLAYBOOK_MAPPING.items():
            print(f"üéØ **{theme}**")
            print(f"   üìö Playbooks: {', '.join(playbooks)}")
            print()

def main():
    """Funci√≥n principal."""
    parser = argparse.ArgumentParser(
        description='The Mighty Task - Procesador de Playbooks',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Ejemplos de uso:

  # Procesar playbooks para un tema y fecha espec√≠ficos
  python scripts/playbook-processor.py --date="2024-01-15" --theme="BACKEND-API-SETUP"
  
  # Procesar un playbook espec√≠fico
  python scripts/playbook-processor.py --playbook="DOC006" --output-dir="daily-work/2024-01-15_BACKEND-API-SETUP/support-docs"
  
  # Listar todos los playbooks disponibles
  python scripts/playbook-processor.py --list-playbooks
  
  # Escanear y mostrar estado de todos los playbooks
  python scripts/playbook-processor.py --scan-all

Playbooks disponibles: """ + ", ".join(PLAYBOOK_FILE_MAPPING.keys())
    )
    
    parser.add_argument('--date', 
                       type=str,
                       help='Fecha de la sesi√≥n (formato YYYY-MM-DD)')
    
    parser.add_argument('--theme',
                       type=str, 
                       help='Tema de la sesi√≥n (ej: BACKEND-API-SETUP)')
    
    parser.add_argument('--playbook',
                       type=str,
                       help='C√≥digo espec√≠fico de playbook a procesar (ej: DOC006)')
    
    parser.add_argument('--output-dir',
                       type=str,
                       help='Directorio de salida para templates (usado con --playbook)')
    
    parser.add_argument('--list-playbooks',
                       action='store_true',
                       help='Listar todos los playbooks disponibles')
    
    parser.add_argument('--scan-all',
                       action='store_true', 
                       help='Escanear todos los playbooks y mostrar estado')
    
    parser.add_argument('--base-path',
                       type=str,
                       help='Ruta base del proyecto (default: directorio actual)')
    
    args = parser.parse_args()
    
    # Crear procesador
    try:
        processor = PlaybookProcessor(args.base_path)
    except SystemExit:
        return 1
    
    # Listar playbooks
    if args.list_playbooks or args.scan_all:
        processor.list_available_playbooks()
        return 0
    
    # Procesar playbook espec√≠fico
    if args.playbook:
        if not args.output_dir:
            ColoredOutput.error("--output-dir es requerido cuando usas --playbook")
            return 1
        
        # TODO: Implementar procesamiento de playbook espec√≠fico
        ColoredOutput.info("Funcionalidad de playbook espec√≠fico por implementar")
        return 0
    
    # Procesar por tema y fecha
    if args.date and args.theme:
        success = processor.process_theme_playbooks(args.theme, args.date)
        
        if success:
            ColoredOutput.success("¬°Procesamiento completado exitosamente!")
            return 0
        else:
            ColoredOutput.error("Errores durante el procesamiento")
            return 1
    
    # Si no hay argumentos v√°lidos
    ColoredOutput.error("Debes especificar --date y --theme, o usar --list-playbooks")
    parser.print_help()
    return 1

if __name__ == '__main__':
    sys.exit(main())
